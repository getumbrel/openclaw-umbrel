const http = require("http");
const net = require("net");
const fs = require("fs");
const fsp = require("fs").promises;
const path = require("path");
const { spawn, exec } = require("child_process");
const { promisify } = require("util");
const execAsync = promisify(exec);
const pty = require("/app/node_modules/node-pty");
const WebSocket = require("/app/node_modules/ws");

const CONFIG_DIR = process.env.OPENCLAW_DATA_DIR || "/data/.openclaw";
const CONFIG_FILE = path.join(CONFIG_DIR, "openclaw.json");
const ENV_FILE = path.join(CONFIG_DIR, ".env");
const PORT = parseInt(process.env.SETUP_PORT || "18789");
const OPENCLAW_PORT = 18790; // Internal port for OpenClaw gateway
const SKELETON_DIR = "/home-skeleton";

let openclawProcess = null;
let ptyProcess = null;

function readEnv() {
  const env = {};
  try {
    if (fs.existsSync(ENV_FILE)) {
      const content = fs.readFileSync(ENV_FILE, "utf8");
      content.split("\n").forEach((line) => {
        const match = line.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/);
        if (match) {
          env[match[1]] = match[2];
        }
      });
    }
  } catch (e) {
    console.error("Error reading env:", e);
  }
  return env;
}

function writeEnv(env) {
  const lines = ["# OpenClaw Configuration", "# Generated by setup wizard", ""];
  for (const [key, value] of Object.entries(env)) {
    if (value) {
      lines.push(`${key}=${value}`);
    }
  }
  fs.writeFileSync(ENV_FILE, lines.join("\n") + "\n", { mode: 0o600 });
}

function writeConfig(config) {
  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2), { mode: 0o600 });
}

function ensureConfigDir() {
  if (!fs.existsSync(CONFIG_DIR)) {
    fs.mkdirSync(CONFIG_DIR, { recursive: true });
  }
  const workspaceDir = path.join(CONFIG_DIR, "workspace");
  if (!fs.existsSync(workspaceDir)) {
    fs.mkdirSync(workspaceDir, { recursive: true });
  }
}

// Check if a directory is empty
async function isDirEmpty(dirPath) {
  try {
    const entries = await fsp.readdir(dirPath);
    return entries.length === 0;
  } catch {
    return true; // If we can't read it, treat as empty
  }
}

// Copy files from /home-skeleton to $HOME if they don't exist or are empty
async function initializeHome() {
  const homeDir = process.env.HOME;

  try {
    const entries = await fsp.readdir(SKELETON_DIR, { withFileTypes: true });

    for (const entry of entries) {
      const srcPath = path.join(SKELETON_DIR, entry.name);
      const destPath = path.join(homeDir, entry.name);

      try {
        await fsp.access(destPath);
        // Exists - check if it's an empty directory
        if (entry.isDirectory() && (await isDirEmpty(destPath))) {
          console.log(
            `${entry.name} exists but is empty, copying contents inside...`
          );
          await execAsync(`cp -r "${srcPath}/." "${destPath}/"`);
        } else {
          console.log(`Skipping ${entry.name} (already exists)`);
        }
      } catch {
        // Doesn't exist, copy it
        console.log(`Copying ${entry.name} to home...`);
        if (entry.isDirectory()) {
          await execAsync(`cp -r "${srcPath}" "${destPath}"`);
        } else {
          await fsp.copyFile(srcPath, destPath);
        }
      }
    }
    console.log("Home directory initialized");
  } catch (err) {
    console.error("Error initializing home:", err.message);
  }
}

function readConfig() {
  try {
    if (fs.existsSync(CONFIG_FILE)) {
      return JSON.parse(fs.readFileSync(CONFIG_FILE, "utf8"));
    }
  } catch (e) {
    console.error("Error reading config:", e);
  }
  return null;
}

function getGatewayToken() {
  const env = readEnv();
  if (env.OPENCLAW_GATEWAY_TOKEN) return env.OPENCLAW_GATEWAY_TOKEN;
  if (process.env.OPENCLAW_GATEWAY_TOKEN) return process.env.OPENCLAW_GATEWAY_TOKEN;
  const config = readConfig();
  if (config && config.gateway && config.gateway.auth && config.gateway.auth.token) {
    return config.gateway.auth.token;
  }
  return null;
}

function isConfigured() {
  // Check if the CLI onboard has been completed (writes wizard section to config)
  const config = readConfig();
  if (config && config.wizard) {
    return true;
  }

  const env = readEnv();
  return !!(
    env.ANTHROPIC_API_KEY ||
    env.OPENAI_API_KEY ||
    env.GEMINI_API_KEY ||
    env.MOONSHOT_API_KEY ||
    env.MINIMAX_API_KEY ||
    env.DASHSCOPE_API_KEY ||
    env.ZAI_API_KEY ||
    env.VENICE_API_KEY ||
    env.XAI_API_KEY ||
    env.GROQ_API_KEY ||
    env.CEREBRAS_API_KEY ||
    env.MISTRAL_API_KEY ||
    env.COPILOT_GITHUB_TOKEN ||
    env.OLLAMA_API_KEY ||
    env.OPENROUTER_API_KEY ||
    process.env.ANTHROPIC_API_KEY ||
    process.env.OPENAI_API_KEY ||
    process.env.GEMINI_API_KEY ||
    process.env.MOONSHOT_API_KEY ||
    process.env.MINIMAX_API_KEY ||
    process.env.DASHSCOPE_API_KEY ||
    process.env.ZAI_API_KEY ||
    process.env.VENICE_API_KEY ||
    process.env.XAI_API_KEY ||
    process.env.GROQ_API_KEY ||
    process.env.CEREBRAS_API_KEY ||
    process.env.MISTRAL_API_KEY ||
    process.env.COPILOT_GITHUB_TOKEN ||
    process.env.OLLAMA_API_KEY ||
    process.env.OPENROUTER_API_KEY
  );
}

function reconcileConfig() {
  const config = readConfig();
  if (!config) return;

  let changed = false;

  // Ensure allowInsecureAuth is set (needed for Umbrel's auth proxy)
  if (!config.gateway) config.gateway = {};
  if (!config.gateway.controlUi) config.gateway.controlUi = {};
  if (!config.gateway.controlUi.allowInsecureAuth) {
    config.gateway.controlUi.allowInsecureAuth = true;
    changed = true;
    console.log("Patched config: enabled allowInsecureAuth");
  }

  // Disable device auth (would break access via umbrel.local)
  if (!config.gateway.controlUi.dangerouslyDisableDeviceAuth) {
    config.gateway.controlUi.dangerouslyDisableDeviceAuth = true;
    changed = true;
    console.log("Patched config: disabled device auth");
  }

  // Disable update checks (updates are managed by Umbrel via Docker image bumps)
  if (!config.update) config.update = {};
  if (config.update.checkOnStart !== false) {
    config.update.checkOnStart = false;
    changed = true;
    console.log("Patched config: disabled update check on start");
  }

  if (changed) {
    writeConfig(config);
  }

  // Sync gateway token to .env so the proxy always has it
  const token = config.gateway && config.gateway.auth && config.gateway.auth.token;
  if (token) {
    const env = readEnv();
    if (env.OPENCLAW_GATEWAY_TOKEN !== token) {
      env.OPENCLAW_GATEWAY_TOKEN = token;
      writeEnv(env);
      console.log("Synced gateway token to .env");
    }
  }
}

// TODO: Handle corrupted/broken configs.

function startOpenclaw() {
  if (openclawProcess) {
    console.log("OpenClaw already running");
    return;
  }

  reconcileConfig();

  console.log("Starting OpenClaw gateway...");
  openclawProcess = spawn(
    "openclaw",
    ["gateway", "--port", OPENCLAW_PORT.toString()],
    {
      stdio: "inherit",
      env: {
        ...process.env,
        ...readEnv(),
      },
    }
  );

  openclawProcess.on("exit", (code) => {
    console.log(`OpenClaw exited with code ${code}`);
    openclawProcess = null;
  });
}

// Read static files at startup
const SETUP_HTML = fs.readFileSync(path.join(__dirname, "setup.html"), "utf8");
const LOGO = fs.readFileSync(path.join(__dirname, "logo.webp"));
const LOADING_HTML = `<!DOCTYPE html>
<html><head><meta charset="UTF-8"><title>Starting...</title>
<meta http-equiv="refresh" content="2">
<style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;display:flex;align-items:center;justify-content:center;height:100vh;background:#0D0D0D;color:#F0EDE8;}</style>
</head><body><div><h1>Starting OpenClaw...</h1><p>Please wait, this may take a moment.</p></div></body></html>`;

function proxyToOpenclaw(req, res) {
  const token = getGatewayToken();

  // For the root path, redirect to include token if not present
  const url = new URL(req.url, `http://${req.headers.host}`);
  if (token && req.url === "/" && !url.searchParams.has("token")) {
    res.writeHead(302, { Location: `/?token=${token}` });
    res.end();
    return;
  }

  const headers = { ...req.headers };
  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
  }

  const options = {
    hostname: "127.0.0.1",
    port: OPENCLAW_PORT,
    path: req.url,
    method: req.method,
    headers: headers,
  };

  const proxy = http.request(options, (proxyRes) => {
    res.writeHead(proxyRes.statusCode, proxyRes.headers);
    proxyRes.pipe(res);
  });

  proxy.on("error", () => {
    // OpenClaw not ready yet, show loading page
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(LOADING_HTML);
  });

  req.pipe(proxy);
}

// Handle WebSocket upgrade requests
function handleUpgrade(req, socket, head) {
  const token = getGatewayToken();

  // Connect to OpenClaw gateway
  const proxySocket = net.connect(OPENCLAW_PORT, "127.0.0.1", () => {
    // Rebuild the upgrade request with auth header
    let requestLine = `${req.method} ${req.url} HTTP/1.1\r\n`;

    // Copy headers and add auth
    const headers = { ...req.headers };
    if (token) {
      headers["authorization"] = `Bearer ${token}`;
    }

    let headerLines = "";
    for (const [key, value] of Object.entries(headers)) {
      if (Array.isArray(value)) {
        value.forEach((v) => (headerLines += `${key}: ${v}\r\n`));
      } else {
        headerLines += `${key}: ${value}\r\n`;
      }
    }

    // Send the upgrade request to OpenClaw
    proxySocket.write(requestLine + headerLines + "\r\n");
    if (head && head.length) {
      proxySocket.write(head);
    }

    // Pipe data between client and OpenClaw
    socket.pipe(proxySocket);
    proxySocket.pipe(socket);
  });

  proxySocket.on("error", (err) => {
    console.error("WebSocket proxy error:", err.message);
    socket.end();
  });

  socket.on("error", (err) => {
    console.error("Client socket error:", err.message);
    proxySocket.end();
  });

  socket.on("close", () => {
    proxySocket.end();
  });

  proxySocket.on("close", () => {
    socket.end();
  });
}

const server = http.createServer((req, res) => {
  // Serve static assets for setup UI
  if (req.url === "/logo.webp") {
    res.writeHead(200, { "Content-Type": "image/webp", "Cache-Control": "public, max-age=86400" });
    res.end(LOGO);
    return;
  }

  if (!isConfigured()) {
    if (req.url !== "/") {
      res.writeHead(302, { Location: "/" });
      res.end();
      return;
    }
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(SETUP_HTML);
    return;
  }

  // If configured but OpenClaw not running, start it
  if (!openclawProcess) {
    startOpenclaw();
  }

  // Proxy to OpenClaw
  proxyToOpenclaw(req, res);
});

// WebSocket server for the interactive terminal
const wss = new WebSocket.Server({ noServer: true });

wss.on("connection", (ws) => {
  console.log("Terminal WebSocket connected");

  // Only one setup session at a time â€” kill any existing PTY (e.g. stale tab)
  if (ptyProcess) {
    try { ptyProcess.kill(); } catch (e) {}
    ptyProcess = null;
  }

  // Spawn openclaw onboard with flags that skip everything except provider/API key selection.
  // The CLI generates its own gateway token and writes it to openclaw.json.
  // reconcileConfig() syncs that token to .env when startOpenclaw() runs after setup.
  ensureConfigDir();
  ptyProcess = pty.spawn("openclaw", [
    "onboard",
    "--flow", "quickstart",
    "--accept-risk",
    "--skip-channels",
    "--skip-skills",
    "--skip-daemon",
    "--skip-ui",
    "--skip-health",
    "--mode", "local",
    "--gateway-port", OPENCLAW_PORT.toString(),
  ], {
    name: "xterm-256color",
    cols: 80,
    rows: 24,
    cwd: CONFIG_DIR,
    env: {
      ...process.env,
      ...readEnv(),
      TERM: "xterm-256color",
    },
  });

  // PTY output -> WebSocket
  ptyProcess.onData((data) => {
    try {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "output", data }));
      }
    } catch (e) {
      console.error("Error sending PTY output:", e.message);
    }
  });

  // PTY exit -> notify client
  ptyProcess.onExit(({ exitCode }) => {
    console.log(`openclaw onboard exited with code ${exitCode}`);
    try {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "exit", code: exitCode }));
      }
    } catch (e) {
      console.error("Error sending exit message:", e.message);
    }
    ptyProcess = null;
  });

  // WebSocket input -> PTY
  ws.on("message", (msg) => {
    try {
      const parsed = JSON.parse(msg);
      if (parsed.type === "input" && ptyProcess) {
        ptyProcess.write(parsed.data);
      } else if (parsed.type === "resize" && ptyProcess) {
        ptyProcess.resize(parsed.cols, parsed.rows);
      }
    } catch (e) {
      console.error("Error processing terminal input:", e.message);
    }
  });

  ws.on("close", () => {
    console.log("Terminal WebSocket closed");
    if (ptyProcess) {
      try { ptyProcess.kill(); } catch (e) {}
      ptyProcess = null;
    }
  });
});

// Handle WebSocket upgrades
server.on("upgrade", (req, socket, head) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // Route /api/terminal to the PTY WebSocket server
  if (url.pathname === "/api/terminal") {
    wss.handleUpgrade(req, socket, head, (ws) => {
      wss.emit("connection", ws, req);
    });
    return;
  }

  if (!isConfigured()) {
    socket.end("HTTP/1.1 503 Service Unavailable\r\n\r\n");
    return;
  }

  if (!openclawProcess) {
    startOpenclaw();
  }

  handleUpgrade(req, socket, head);
});

// Initialize home directory from skeleton
initializeHome();

ensureConfigDir();

// Check if already configured
if (isConfigured()) {
  console.log("OpenClaw is configured, starting gateway...");
  startOpenclaw();
} else {
  console.log("OpenClaw not configured, showing setup UI...");
}

server.listen(PORT, "0.0.0.0", () => {
  console.log(`Setup server listening on port ${PORT}`);
});

// Graceful shutdown: Docker sends SIGTERM on stop/restart/update.
// Without this, child processes (gateway, PTY) may get hard-killed
// mid-write and corrupt config or state files.
process.on("SIGTERM", () => {
  console.log("Received SIGTERM, shutting down...");
  if (ptyProcess) {
    try { ptyProcess.kill(); } catch (e) {}
  }
  if (openclawProcess) {
    openclawProcess.kill("SIGTERM");
  }
  server.close();
});
